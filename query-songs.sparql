PREFIX xyz: <http://sparql.xyz/facade-x/data/>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX fx: <http://sparql.xyz/facade-x/ns/>
PREFIX mm:  <http://w3id.org/polifonia/ontology/music-meta/>
PREFIX mp:  <http://w3id.org/polifonia/ontology/music-projection/>
PREFIX mr:  <http://w3id.org/polifonia/ontology/music-representation/>
PREFIX core:  <http://w3id.org/polifonia/ontology/core/>
PREFIX tunes:  <http://w3id.org/polifonia/ontology/tunes/>
PREFIX pon-resource: <http://w3id.org/polifonia/resource/tunes/>
PREFIX prov: <http://www.w3.org/ns/prov#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>

# UNMATCHED FIELDS:
    # - song_stanza_number: what does stanza refer to?
    #   PVK: The stanza of the song of which the melody is a transcription
    # - song_voice_number: what does voice refer to?
    #   PVK: The voice (or: part) (melody, bass)
    # - song_formatted_source: what does formatted source refer to?
    #   PVK: string with formatted reference to the source.
    # - song_title_in_source # This is the verbatim title of the song in its source (could only be a serial number).
    # SOURCE
    # - all the "source" attributes, such as source_publisher: do they refer to the mm:Score class? If so, we need to add a bunch of classes to the Tunes Ontology
    #   PVK: No, they refer to the source (book, recording, leaflet, etc) of the melody
    # - source_id and tunefamily_id: what is the difference between the two?
    #   PVK: source_id is an unique identifier for a source, tunefamily_id is unique identifier for a tune family.

# TODOs
    # - split dates into start and end dates
    # - clean data (e.g. remove trailing 'c') so that they can be converted into integers/dates datatypes


CONSTRUCT {
    ?song_iri a mm:MusicEntity ;
        core:id ?song_id ;  # add to ontology PVK: This is the ID of the song in the collection.
        rdfs:label ?song_title ;
        core:title ?song_title ;
        # mm:hasComposer ?composer_iri_validated ;
        core:description ?song_description_url ; # PVK: This is a url to a webpage for the song. is core:description the right predicate?
        core:isMemberOf ?tunefamily_iri ;
        # core:hasPart ?abstractScoreUri ;
        # core:hasPart ?instrumentationUri ;
        # core:hasPart ?textUri ;
        # mm:isRealisedBy ?musical_performance_iri ;
        # mm:isRecordedBy ?recording_process_iri ;
        core:isInvolvedIn [
            a tunes:CollectionMembership ;
            core:hasMembershipStrength ?tunefamily_confidence ;
            core:hasMember ?tunefamily_iri ;
        ] .

    # Tune family

    ?tunefamily_iri a core:Collection, tunes:TuneFamily ;
        core:isDefinedBy ?tune_collection_concept_iri ;
        core:id ?tunefamily_id ;  # add to ontology
        core:name ?tunefamily_name ;
        core:description ?tunefamily_description_url ;
        core:hasMember ?song_iri .

    ?tune_collection_concept_iri a core:CollectionConcept ;
        core:hasMember ?tunefamily_iri .  # add here more triples?

    # ?composer_iri_validated a mm:MusicArtist, mm:Musician ;
    #     rdfs:label ?composer_name ;
    #     core:name ?composer_name ;
    #     core:id ?composer_id ;  # add to ontology
    #     core:activityStartDate ?composer_start_date ;
    #     core:activityEndDate ?composer_end_date ;
    #     core:hasAgentRole ?composer_role ;  # add to ontology
    #     mm:creates ?song_iri .

    # # ?abstractScoreUri a mm:AbstractScore ;
    # #     mm:hasText ?textUri ;
    # #     core:hasPart ?ANYTHING_GOES_HERE? ;  # TODO: check if anything fits this class. In the example diagram we have movements or sections
    # #     mm:hasFormType ?ANYTHING_GOES_HERE? ;  # TODO: check if anything fits this class. In the example diagram we have "sonatas" or "concertos"
    # #     mm:orderNumber ?ANYTHING_GOES_HERE? .  # TODO: check if anything fits this class. It takes a string as value (datatype)

    # ?instrumentationUri a mm:Instrumentation ;
    #     mm:hasScore ?score_uri ;
    #     mm:isRealisedIn ?score_part_iri .

    # ?source_iri a mm:Score, mm:MusicSheet ; #PVK: The source is not a score. The score (or recording) is IN a source.
    #     core:id ?source_id ;  # add to ontology
    #     core:title ?source_title ;  # add to ontology
    #     core:description ?source_description_url ;  # add to ontology
    #     mm:hasScan ?source_scan_url ;  # add to ontology
    #     mm:hasLibrarySiglum ?source_library_siglum ;  # add to ontology
    #     mm:hasCurrentOwner ?source_current_owner_iri ;  # add to ontology
    #     mm:hasScorePart ?score_part_iri ;
    #     mm:hasPubblicationSituation [
    #         a mm:PublicationSituation ;
    #         core:hasPlace [
    #             a core:Place ;
    #             core:name ?source_place_of_publishing ] ;
    #         core:hasTimeInterval [
    #             a core:TimeInterval ;
    #             core:startDate ?source_date ;  # TODO: split dates into start and end dates
    #             core:endDate ?source_date ] ;  # TODO: split dates into start and end dates
    #         mm:hasPublisher ?source_publisher_iri ;
    #     ] ;
    #     core:hasType ?source_type ;  # add to ontology
    #     mm:hasScribe ?source_scribe_iri .

    # ?source_publisher_iri a core:Agent ;
    #     core:id ?source_publisher_id ;  # add to ontology
    #     core:name ?source_publisher .        

    # ?source_scribe_iri a core:Agent ;  
    #     core:id ?source_scribe_id ;  # add to ontology
    #     core:name ?source_scribe_name ;
    #     core:activityStartDate ?source_scribe_year_of_birth ;
    #     core:activityEndDate ?source_scribe_year_of_birth ;
    #     core:placeOfBirth ?source_scribe_place_of_birth_name ;
    #     core:placeOfBirthLatitude ?source_scribe_place_of_birth_latitude ;
    #     core:placeOfBirthLongitude ?source_scribe_place_of_birth_longitude .

    # ?score_part_iri a mm:ScorePart .

    # ?source_current_owner_iri a core:Agent ;
    #     core:id ?source_current_owner_id ;  # add to ontology
    #     core:name ?source_current_owner_name .

    # ?textUri a mm:Text, mm:Lyrics ;
    #     core:hasText [ a mm:TextFragment ;
    #         core:text ?song_lyrics_first_line ] ;
    #     core:isMemberOf ?song_textfamily_iri .  

    # ?musical_performance_iri a mm:MusicalPerformance, core:InformationRealization ;
    #     mm:isPerformedBy ?song_singer_iri .

    # ?recording_process_iri a mm:RecordingProcess ;
    #     mm:producesRecording ?recording_uri ;
    #     core:hasPlace [
    #         a core:Place ;
    #         core:name ?song_place_of_recording_name ;
    #         core:latitude ?song_place_of_recording_latitude ;
    #         core:longitude ?song_place_of_recording_longitude ] ;
    #     core:hasTimeInterval [
    #         a core:TimeInterval ;
    #         core:startDate ?song_date_of_recording_start ;  # TODO: split dates into start and end dates
    #         core:endDate ?song_date_of_recording_end ] .  # TODO: split dates into start and end dates
        

    # ?recording_uri a mm:Recording ;
    #     core:url ?song_audio_url .

    # ?song_textfamily_iri a tunes:TextFamily ;
    #     core:isDefinedBy ?text_collection_concept .


    # ?text_collection_concept a core:CollectionConcept ;
    #     core:hasMember ?song_textfamily_iri .  # add here more triples?


    # ?song_singer_iri a mm:MusicArtist, mm:Musician ;  # not working, check
    #     rdfs:label ?song_singer_name ;
    #     rdfs:label ?song_singer_name ;
    #     core:name ?song_singer_name ;
    #     core:artistId ?song_singer_id ;  # add to ontology
    #     core:activityStartDate ?song_singer_year_of_birth ;
    #     core:activityEndDate ?song_singer_year_of_birth ;
    #     core:placeOfBirth ?song_singer_place_of_birth_name ;
    #     core:placeOfBirthLatitude ?song_singer_place_of_birth_latitude ;
    #     core:placeOfBirthLongitude ?song_singer_place_of_birth_longitude ;
    #     core:hasAgentRole ?performer_role ;
    #     mm:isPerformerOf ?song_iri .  # add to ontology

}

WHERE {
    SERVICE <x-sparql-anything:> {

        fx:properties fx:location ?_filepath ;
            fx:media-type  "application/json" ;
            fx:blank-nodes true .

        #######################
        # FIRST LEVEL
        #######################

        ?base_root a fx:root ;
            ?tune_slot ?tune_base .

        ?tune_base 
            xyz:song_iri ?song_iri_temp ;
            xyz:song_title ?song_title .

        OPTIONAL { ?tune_base xyz:song_id ?song_id . }
        OPTIONAL { ?tune_base xyz:collection ?collection . }
        OPTIONAL { ?tune_base xyz:song_description_url ?song_description_url . }
        OPTIONAL { ?tune_base xyz:song_title_in_source ?song_title_in_source . }
        OPTIONAL { ?tune_base xyz:song_types ?song_types . }  # list
        OPTIONAL { ?tune_base xyz:composers ?composers . } # list
        OPTIONAL { ?tune_base xyz:arrangement ?arrangement . } 
        OPTIONAL { ?tune_base xyz:song_stanza_number ?song_stanza_number . }
        OPTIONAL { ?tune_base xyz:song_voice_number ?song_voice_number . }
        OPTIONAL { ?tune_base xyz:song_formatted_source ?song_formatted_source . }
        OPTIONAL { ?tune_base xyz:source_id ?source_id . }
        OPTIONAL { ?tune_base xyz:source_iri ?source_iri . }
        OPTIONAL { ?tune_base xyz:source_title ?source_title . }
        OPTIONAL { ?tune_base xyz:source_publisher ?source_publisher . }
        OPTIONAL { ?tune_base xyz:source_place_of_publishing ?source_place_of_publishing . }
        OPTIONAL { ?tune_base xyz:source_date ?source_date . }
        OPTIONAL { ?tune_base xyz:source_sorting_year ?source_sorting_year . }
        OPTIONAL { ?tune_base xyz:source_library_siglum ?source_library_siglum . }
        OPTIONAL { ?tune_base xyz:source_scan_url ?source_scan_url . }
        OPTIONAL { ?tune_base xyz:source_description_url ?source_description_url . }
        OPTIONAL { ?tune_base xyz:source_type ?source_type . }
        OPTIONAL { ?tune_base xyz:source_scribes ?source_scribes . } # list
        OPTIONAL { ?tune_base xyz:source_current_owner_id ?source_current_owner_id . }
        OPTIONAL { ?tune_base xyz:source_current_owner_iri ?source_current_owner_iri . }
        OPTIONAL { ?tune_base xyz:source_current_owner_name ?source_current_owner_name . }
        OPTIONAL { ?tune_base xyz:source_former_owners ?source_former_owners . }
        OPTIONAL { ?tune_base xyz:song_serial_number_in_source ?song_serial_number_in_source . }
        OPTIONAL { ?tune_base xyz:song_page_number_in_source ?song_page_number_in_source . }
        OPTIONAL { ?tune_base xyz:song_singers ?song_singers . }  # list
        OPTIONAL { ?tune_base xyz:song_date_of_recording ?song_date_of_recording . }
        OPTIONAL { ?tune_base xyz:song_place_of_recording_name ?song_place_of_recording_name . }
        OPTIONAL { ?tune_base xyz:song_place_of_recording_latitude ?song_place_of_recording_latitude . }
        OPTIONAL { ?tune_base xyz:song_place_of_recording_longitude ?song_place_of_recording_longitude . }
        OPTIONAL { ?tune_base xyz:song_textfamily_id ?song_textfamily_id . }
        OPTIONAL { ?tune_base xyz:song_textfamily_iri ?song_textfamily_iri . }
        OPTIONAL { ?tune_base xyz:song_lyrics_first_line ?song_lyrics_first_line . }
        OPTIONAL { ?tune_base xyz:tunefamily_id ?tunefamily_id . }
        OPTIONAL { ?tune_base xyz:tunefamily_iri ?tunefamily_iri_temp . }
        OPTIONAL { ?tune_base xyz:tunefamily_name ?tunefamily_name . }
        OPTIONAL { ?tune_base xyz:tunefamily_description_url ?tunefamily_description_url . }
        OPTIONAL { ?tune_base xyz:tunefamily_confidence ?tunefamily_confidence . }
        OPTIONAL { ?tune_base xyz:song_related_to_tunefamily_ids ?song_related_to_tunefamily_ids . } # list
        OPTIONAL { ?tune_base xyz:song_geographic_origin ?song_geographic_origin . } # list
        OPTIONAL { ?tune_base xyz:song_image_url ?song_image_url . }
        OPTIONAL { ?tune_base xyz:song_audio_url ?song_audio_url . }
        OPTIONAL { ?tune_base xyz:song_comment ?song_comment . }

        BIND (IRI(?song_iri_temp) AS ?song_iri)

        # Tune family

        BIND(IRI(concat(str(pon-resource:), "TuneFamilyConcept")) as ?tune_collection_concept_iri)

        BIND(IF(BOUND(?tunefamily_iri_temp), IRI(?tunefamily_iri_temp), ?nothing) AS ?tunefamily_iri)

        # #######################
        # # NESTED
        # #######################

        # # COMPOSERS
        # ?composers fx:anySlot ?composer_list .
        # ?composer_list xyz:composer_id ?composer_id ;
        #     xyz:composer_iri ?composer_iri_temp ;
        #     xyz:composer_name ?composer_name ;
        #     xyz:composer_dates ?composer_dates .

        # # if composer_iri does not exist, generate one
        # BIND (IF((?composer_iri_temp != ""), IRI(?composer_iri_temp), IRI(CONCAT(STR(pon-resource:MusicArtist), "/", SHA1(CONCAT(?composer_name))))) AS ?composer_iri_validated)    # IRI generation not stable
        # BIND ((STRBEFORE(STR(?composer_dates), "-")) AS ?composer_start_date)
        # BIND ((STRAFTER(STR(?composer_dates), "-")) AS ?composer_end_date)

        # # SOURCE SCRIBES
        # ?source_scribes fx:anySlot ?source_scribe_list .
        # ?source_scribe_list xyz:source_scribe_id ?source_scribe_id ;
        #     xyz:source_scribe_iri ?source_scribe_iri ;
        #     xyz:source_scribe_name ?source_scribe_name ;
        #     xyz:source_scribe_dates ?source_scribe_dates .

        # # SONG TYPES
        # OPTIONAL {
        #     ?song_types fx:anySlot ?song_type_list .
        # }

        # # SOURCE SCRIBES
        # OPTIONAL {
        #     ?song_singers fx:anySlot ?song_singer_list .
        # }

        # # SONG SINGERS
        # OPTIONAL {
        #     ?song_singers fx:anySlot ?song_singer_list .
        #     ?song_singer_list xyz:singer_id ?song_singer_id ;
        #         xyz:singer_iri ?song_singer_iri_temp ;
        #         xyz:singer_name ?song_singer_name ;
        #         xyz:singer_year_of_birth ?song_singer_year_of_birth ;
        #         xyz:singer_place_of_birth_name ?song_singer_place_of_birth_name ;
        #         xyz:singer_place_of_birth_latitude ?song_singer_place_of_birth_latitude ;
        #         xyz:singer_place_of_birth_longitude ?song_singer_place_of_birth_longitude ;
        #         xyz:singer_nlb_url ?song_singer_nlb_url.
        # }

        # # if singer_iri does not exist, generate one
        # BIND (IRI(?song_singer_iri_temp) AS ?song_singer_iri)

        # # SONG RELATED TO TUNEFAMILY IDS
        # OPTIONAL {
        #     ?song_related_to_tunefamily_ids fx:anySlot ?song_related_to_tunefamily_id_list .
        # }

        # # SONG GEOGRAPHIC ORIGIN
        # OPTIONAL {
        #     ?song_geographic_origin fx:anySlot ?song_geographic_origin_list .
        # }

        # # URIs
        # BIND (IRI(CONCAT(STR(pon-resource:AgentRole), "/", "Composer")) AS ?composer_role)
        # BIND (IRI(CONCAT(STR(pon-resource:AgentRole), "/", "Performer")) AS ?performer_role)
        # # BIND (IRI(CONCAT(STR(pon-resource:Recording), "/", SHA1(CONCAT('recording_', ?title, '_', ?single_performer)))) AS ?recording_uri)


    }
}
